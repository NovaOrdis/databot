#!/bin/bash

#
# Command-line wrapper script - generated from Nova Ordis Release Tools' run-wrapper-template
#
# For more details see https://kb.novaordis.com/index.php/novaordis-release-tools
#

reldir=$(dirname $0)
home_dir=${reldir}/..
main_class=${main_class}
memory=1024m
verbose=false

function debug() {
    ${verbose} && echo "$@" 1>&2;
    return 0
}

function debug-arguments {
    ${verbose} && echo "${FUNCNAME[1]}($@)" 1>&2;
    return 0
}

function fail {
    echo "[error]: $@" 1>&2 && exit 1
}

function display-help() {
    local help_file=${reldir}/../lib/HELP
    [ ! -f ${help_file} ] && fail "HELP file ${help_file} not available, possible because of faulty installation"
    cat ${help_file}
}

function display-version() {
    local version_file=${reldir}/../lib/VERSION
    [ ! -f ${version_file} ] && fail "VERSION file ${version_file} not available, possible because of faulty installation"
    cat ${version_file}
}

function get_java_home() {
    # local java_home="/usr/java/jdk64-1.7.0_45"
    local java_home=""
    if [ -n "${JAVA_HOME}" ]; then
        debug "using JAVA_HOME from environment ${JAVA_HOME}"
        java_home=${JAVA_HOME}
    else
        local name;
        name=$(uname -n)
        name=${name##*.}
        [ "${name}" = "local" ] && java_home="/Library/Java/JavaVirtualMachines/jdk1.7.0_60.jdk/Contents/Home"
    fi
    echo ${java_home}
}

function get_classpath() {
    debug "${FUNCNAME[0]}: home_dir=${home_dir}"
    local first=true
    for i in ${home_dir}/lib/*.jar; do
        ${first} && first=false || echo -n ":"
        echo -n ${i}
    done
}

# may return empty string or more than one PID (in a space separated list)
function get-pids() {
    local pids=$(ps -ef | grep java | grep ${main_class} | awk '{print $2}')
    echo ${pids}
}

function stop() {

    local pids
    pids=$(get-pids) || fail "failed to get pids"

    [ -z "${pids}" ] && { echo "no os-stats background processes running on $(uname -n)"; exit 0; }

    local force=false
    local signal=""
    local signal_name="SIGTERM"
    if ${force}; then
        signal="-9"
        signal_name="SIGKILL"
    fi

    for pid in ${pids}; do
        kill ${signal} ${pid} && \
            echo "sent ${signal_name} into os-stats process (${pid})" || \
            echo "fail to send ${signal_name} into os-stats process with pid ${pid}"
    done
}

function status() {

    local pids
    pids=$(get-pids) || fail "failed to get pids"
    [ -z "${pids}" ] && { echo "no os-stats background processes running on $(uname -n)"; exit 0; }
    echo "os-status with pid ${pids} running"
}

debug_args=""
output_settings=""
foreground=false
do_kill=false

while [ "$1" != "" ]; do
    if [ "$1" = "help" -o "$1" = "--help" ]; then
        display-help;
        exit 0
    elif [ "$1" = "version" -o "$1" = "--version" ]; then
        display-version;
        exit 0
    elif [ "$1" = "--debug" ]; then
        debug_args="-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5011"
        verbose=true
    elif [ "$1" = "--verbose" -o "$1" = "-v" ]; then
        verbose=true
    elif [ "$1" = "--foreground" -o "$1" = "-fg" ]; then
        foreground=true
        #
        # also pass it as a java process argument, to let it know to ignore output.file
        #
        args="${args} $1"
    elif [ "$1" = "stop" ]; then
        stop && exit 0 || fail "failed to stop background os-stats"
    elif [ "$1" = "status" ]; then
        status && exit 0
    else
        #
        # if the argument contains spaces, it means double quotes were used, we need to pass those down so the java
        # command parsing line logic can detect quoted strings; more than that, if the double quoted string contains
        # escaped quotes, we want to pass them as such
        #
        if [ "$1" = "${1/ //}" ]; then
            # no spaces, pass as is
            args="${args} $1"
        else
            # quoted string that contains spaces, escape inner quotes, in case they exist
            escaped_inner_quotes=${1//\"/\\\"}
            args="${args} \"${escaped_inner_quotes}\""
        fi
    fi
    shift;
done

#
# check if background processes are running on the system. If they do, report and exist, we only
# want a single process on the VM
#
pids=$(get-pids) || fail "failed to get pids"
[ -n "${pids}" ] && fail "an os-stats process is already running (pid ${pids})"

java_home=$(get_java_home) || fail "failed to get JAVA_HOME"
classpath=$(get_classpath) || fail "failed to build classpath"
java_bin="java"
[ "${java_home}" != "" ] && java_bin="${java_home}/bin/java"

${verbose} && verbose_system_property="-Dverbose=true"

command="${java_bin} -Xms${memory} -Xmx${memory} -cp ${classpath} ${debug_args} ${output_settings} ${verbose_system_property} ${main_class} ${args}"

${verbose} && echo "${command}" 1>&2;

if ${foreground}; then
    ${command}
else
    ${command} &
fi